// Copyright 2023 Harald Albrecht.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build linux

package main

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/thediveo/gitrepofs"
	"github.com/thediveo/gitrepofs/version"
	"golang.org/x/exp/slices"
	"golang.org/x/mod/semver"
)

// libcap git repository URL.
const libcapGitURL = "https://git.kernel.org/pub/scm/libs/libcap/libcap.git"

// The file we're interested in.
const capabilityDefinitionsFile = "libcap/include/uapi/linux/capability.h"

// Name of the Go source file to generate.
const capabilitiesGoFile = "capabilities.go"

// Grabs only the lines in form of "#define CAP_NAME 123" together with their
// preceding comment(s).
var capabilityDefinition = regexp.MustCompile(`(?m)^((?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/\n)+)\n#define (CAP_[A-Z0-9_]+)\s+(\d+)$`)

// Removes the in-comment "*" line beginnings that mess up the godoc rendering
// of comments.
var cleanupCommenting = regexp.MustCompile(`(?m)^\s+\*\s+`)

var combineSingleCommentlines = regexp.MustCompile(`(?m) \*/\s+/\* `)

var removeIndentation = regexp.MustCompile(`(?m)^ +`)

// Grabs the definition for the versioned capability user data array sizes.
var capabilityUserDataLen = regexp.MustCompile(`(?m)^#define _(LINUX_CAPABILITY_U32S_\d+)\s+(\d+)$`)

var capabilitiesTemplate = template.Must(template.New("").Parse(`// Code generated by go generate. DO NOT EDIT.
// Generated from libcap {{ .SemVer }}
// {{ .URL }}
//
//go:generate go run ./internal/updatecaps

package caps

// SemVer of the libcap definitions.
const LibcapSemVer = "{{ .SemVer }}"

const (
	{{ $last := 0 }}
	{{ range .Capabilities -}}
		{{ .Commenting }}
		{{ .Name }} = {{ .BitNo }}
		{{- $last = .BitNo }}
	{{ end }}

	MaxCapabilityNumber = {{ $last }}
)

// CapabilityNameByNumber maps capability bit numbers to their capability (symbolic) names.
var CapabilityNameByNumber = map[int]string{
	{{ range .Capabilities -}}
		{{ .BitNo }}: "{{ .Name }}",
	{{ end }}
}

const (
	{{ range .Sizes -}}
		{{ .Name }} = {{ .Size }}
	{{ end }}
)
`))

// capability describes a single capability with its name and assigned bit
// number.
type capability struct {
	Name       string // symbol name in form of "CAP_..."
	BitNo      int    // bit number; not mask value
	Commenting string
}

// getCaps scans the given contents for definitions of capabilities and returns
// them, sorted by bit number.
func getCaps(contents string) []capability {
	allmatches := capabilityDefinition.FindAllStringSubmatch(contents, -1)
	caps := []capability{}
	for _, match := range allmatches {
		comment, name, value := match[1], match[2], match[3]
		bitno, err := strconv.Atoi(value)
		if err != nil {
			fmt.Printf("malformed %s = %s\n", name, value)
			os.Exit(1)
		}
		comment = cleanupCommenting.ReplaceAllLiteralString(comment, "")
		comment = combineSingleCommentlines.ReplaceAllLiteralString(comment, "\n\n")
		comment = removeIndentation.ReplaceAllLiteralString(comment, "")
		comment = strings.ReplaceAll(comment, "'", "â€™")
		caps = append(caps, capability{
			Name:       name,
			BitNo:      bitno,
			Commenting: strings.TrimSuffix(comment, "\n"),
		})
	}
	slices.SortFunc(caps, func(a, b capability) bool { return a.BitNo < b.BitNo })
	return caps
}

// capusersize describes the versioned sizes as used in the capabilities
// user-space API getcap(2) and setcap(2).
type capusersize struct {
	Name string // versioned symbol name
	Size int    // number of uint32 elements
}

// getSizes scans the given contents for definition of the data sizes for
// different versions of the user-facing getcap/setcap API.
func getSizes(contents string) []capusersize {
	allmatches := capabilityUserDataLen.FindAllStringSubmatch(contents, -1)
	sizes := []capusersize{}
	for _, match := range allmatches {
		size, err := strconv.Atoi(match[2])
		if err != nil {
			fmt.Printf("malformed %s = %s\n", match[1], match[2])
			os.Exit(1)
		}
		sizes = append(sizes, capusersize{
			Name: match[1],
			Size: size,
		})
	}
	slices.SortFunc(sizes, func(a, b capusersize) bool { return a.Size < b.Size })
	return sizes
}

// generates the source code for cap/capabilities.go
func generateCapsSource(semver string, remoteURL string, caps []capability, sizes []capusersize) []byte {
	var source bytes.Buffer
	if err := capabilitiesTemplate.Execute(&source, struct {
		SemVer       string
		URL          string
		Capabilities []capability
		Sizes        []capusersize
	}{
		SemVer:       semver,
		URL:          remoteURL,
		Capabilities: caps,
		Sizes:        sizes,
	}); err != nil {
		fmt.Printf("cannot generate source code, reason: %s\n", err)
	}
	capsgo, err := format.Source(source.Bytes())
	if err != nil {
		fmt.Printf("cannot format generated source code, reason: %s\n", err)
		os.Exit(1)
	}
	return capsgo
}

// Avoid importing and parse the capabilities.go file instead in order to figure
// out the libcap version it was generated from. Returns the semver found, or ""
// if the file is missing or invalid.
func ownSemVer() string {
	fset := token.NewFileSet()
	capsf, err := parser.ParseFile(fset, capabilitiesGoFile, nil, 0)
	if err != nil {
		fmt.Printf("error parsing existing %s, regenerating it anew\n", capabilitiesGoFile)
		return ""
	}
	for _, decl := range capsf.Decls {
		gendecl, ok := decl.(*ast.GenDecl)
		if !ok || gendecl.Tok != token.CONST {
			continue
		}
		for _, spec := range gendecl.Specs {
			valspec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			for _, name := range valspec.Names {
				if name.Name == "LibcapSemVer" {
					namedecl, ok := name.Obj.Decl.(*ast.ValueSpec)
					if !ok {
						continue
					}
					val, ok := namedecl.Values[0].(*ast.BasicLit)
					if !ok {
						continue
					}
					ver := strings.Replace(val.Value, `"`, "", -1)
					fmt.Printf("current cap capabilities version: %s\n", ver)
					return ver
				}
			}
		}
	}
	return ""
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Minute)
	defer cancel()
	fmt.Println("discovering versions...")
	latestSemVer, ref, err := version.LatestReleaseTag(
		ctx, libcapGitURL, version.NewPrefixedTagMatcher("libcap-"))
	if err != nil {
		fmt.Printf("cannot determine latest version of libcap, reason: %s\n", err)
		os.Exit(1)
	}
	latestSemVer = latestSemVer[1:] // remove v prefix
	fmt.Printf("latest release: %s\n", latestSemVer)

	currentSemVer := ownSemVer()
	if !(len(os.Args) >= 2 && os.Args[1] == "force") && semver.Compare("v"+currentSemVer, "v"+latestSemVer) >= 0 {
		fmt.Printf("%s already up to date\n", capabilitiesGoFile)
		os.Exit(0)
	}

	gfs, err := gitrepofs.NewForRevision(ctx, libcapGitURL, ref)
	if err != nil {
		fmt.Printf("cannot fetch version %s of libcap, reason: %s\n", latestSemVer, err)
		os.Exit(1)
	}
	capsDefinitionsCSource, err := fs.ReadFile(gfs, capabilityDefinitionsFile)
	if err != nil {
		fmt.Printf("no %s, reason: %s\n", capabilityDefinitionsFile, err)
		os.Exit(1)
	}

	caps := getCaps(string(capsDefinitionsCSource))
	sizes := getSizes(string(capsDefinitionsCSource))
	source := generateCapsSource(latestSemVer, libcapGitURL, caps, sizes)
	err = os.WriteFile(capabilitiesGoFile, source, 0664)
	if err != nil {
		fmt.Printf("cannot write %s, reason: %s\n", capabilitiesGoFile, err)
		os.Exit(1)
	}
	fmt.Printf("%s generated\n", capabilitiesGoFile)
}
